# Longest Increasing Subsequence

Subsequence: do not need to be continuous

    def lengthOfLIS(self, nums: List[int]) -> int:
        comp = [1 for i in range(len(nums))]
        for i in range(len(nums)):
            for j in range(i):
                if nums[j] < nums[i]:
                    // CORE
                    comp[i] = max(comp[j] + 1,comp[i])

        return max(comp)


# House Robber

    public int rob(int[] nums) {
        int[] dp=new int[nums.length+1];

        dp[1]=nums[0];
        
        for(int i=2;i<nums.length+1;i++){
             // CORE
            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i-1]);
        }
        return dp[dp.length-1];
    }

# N-th Tribonacci Number
    
    Fib + hashtable

    public int tribonacci(int n) {
        int[] ini = new int[]{0,1,1};
        for(int i=3;i<n+1;i++){
             // CORE
            ini[i%3]=ini[0]+ini[1]+ini[2];
        }
        return ini[n%3];   
    }


# Climbing Stairs

    Fib 

        def climbStairs(self, n: int) -> int:
            if n<=2:
                return n
            prevv = 1
            prev = 2
            curr = 0
            
            for i in range(2,n):
                curr = prev+prevv
                
                prevv = prev
                prev = curr
            return curr


define first several steps and using iterations and state transformation function to searching the results.

